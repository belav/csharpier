namespace CSharpier;

using System.Text;
using System.Text.Json;
using CSharpier.Formatters.CSharp;
using CSharpier.SyntaxPrinter;

internal class CSharpScriptFormatter : CSharpFormatter { }

internal class CSharpFormatter : IFormatter
{
    internal static readonly LanguageVersion LanguageVersion = LanguageVersion.Preview;

    Task<CodeFormatterResult> IFormatter.FormatAsync(
        string code,
        PrinterOptions printerOptions,
        CancellationToken cancellationToken
    )
    {
        return FormatAsync(code, printerOptions, cancellationToken);
    }

    internal static Task<CodeFormatterResult> FormatAsync(
        string code,
        PrinterOptions printerOptions
    ) => FormatAsync(code, printerOptions, CancellationToken.None);

    internal static Task<CodeFormatterResult> FormatAsync(
        string code,
        PrinterOptions printerOptions,
        CancellationToken cancellationToken
    ) => FormatAsync(code, printerOptions, SourceCodeKind.Regular, cancellationToken);

    internal static Task<CodeFormatterResult> FormatAsync(
        string code,
        PrinterOptions printerOptions,
        SourceCodeKind sourceCodeKind,
        CancellationToken cancellationToken
    )
    {
        var initialSymbolSet = Array.Empty<string>();

        return FormatAsync(
            ParseText(code, initialSymbolSet, sourceCodeKind, cancellationToken),
            printerOptions,
            sourceCodeKind,
            cancellationToken
        );
    }

    private static SyntaxTree ParseText(
        string codeToFormat,
        IEnumerable<string> preprocessorSymbols,
        SourceCodeKind sourceCodeKind,
        CancellationToken cancellationToken
    )
    {
        return CSharpSyntaxTree.ParseText(
            codeToFormat,
            new CSharpParseOptions(
                LanguageVersion,
                DocumentationMode.Diagnose,
                preprocessorSymbols: preprocessorSymbols,
                kind: sourceCodeKind
            ),
            cancellationToken: cancellationToken
        );
    }

    internal static async Task<CodeFormatterResult> FormatAsync(
        SyntaxTree syntaxTree,
        PrinterOptions printerOptions,
        SourceCodeKind sourceCodeKind,
        CancellationToken cancellationToken
    )
    {
        var syntaxNode = await syntaxTree.GetRootAsync(cancellationToken);
        if (syntaxNode is not CompilationUnitSyntax rootNode)
        {
            throw new Exception(
                "Root was not CompilationUnitSyntax, it was " + syntaxNode.GetType()
            );
        }

        if (
            !printerOptions.IncludeGenerated
            && GeneratedCodeUtilities.BeginsWithAutoGeneratedComment(rootNode)
        )
        {
            return new CodeFormatterResult { Code = syntaxTree.ToString() };
        }

        bool TryGetCompilationFailure(out CodeFormatterResult compilationResult)
        {
            var diagnostics = syntaxTree
                .GetDiagnostics(cancellationToken)
                .Where(o => o.Severity == DiagnosticSeverity.Error && o.Id != "CS1029")
                .ToList();
            if (diagnostics.Any())
            {
                compilationResult = new CodeFormatterResult
                {
                    Code = syntaxTree.ToString(),
                    CompilationErrors = diagnostics,
                    AST = printerOptions.IncludeAST ? PrintAST(rootNode) : string.Empty
                };

                return true;
            }

            compilationResult = CodeFormatterResult.Null;
            return false;
        }

        if (TryGetCompilationFailure(out var result))
        {
            return result;
        }

        try
        {
            var lineEnding = PrinterOptions.GetLineEnding(syntaxTree.ToString(), printerOptions);
            var formattingContext = new FormattingContext
            {
                LineEnding = lineEnding,
                IndentSize = printerOptions.TabWidth,
                UseTabs = printerOptions.UseTabs,
                NewLineBeforeOpenBrace = printerOptions.NewLineBeforeOpenBrace,
                NewLineBeforeElse = printerOptions.NewLineBeforeElse,
                NewLineBeforeCatch = printerOptions.NewLineBeforeCatch,
                NewLineBeforeFinally = printerOptions.NewLineBeforeFinally,
                NewLineBeforeMembersInObjectInitializers = printerOptions.NewLineBeforeMembersInObjectInitializers,
                NewLineBeforeMembersInAnonymousTypes = printerOptions.NewLineBeforeMembersInAnonymousTypes,
                NewLineBetweenQueryExpressionClauses = printerOptions.NewLineBetweenQueryExpressionClauses,
                UsePrettierStyleTrailingCommas = printerOptions.UsePrettierStyleTrailingCommas,
            };
            var document = Node.Print(rootNode, formattingContext);
            var formattedCode = DocPrinter.DocPrinter.Print(document, printerOptions, lineEnding);
            var reorderedModifiers = formattingContext.ReorderedModifiers;
            var reorderedUsingsWithDisabledText = formattingContext.ReorderedUsingsWithDisabledText;

            foreach (var symbolSet in PreprocessorSymbols.GetSets(syntaxTree))
            {
                syntaxTree = ParseText(formattedCode, symbolSet, sourceCodeKind, cancellationToken);

                if (TryGetCompilationFailure(out result))
                {
                    return result;
                }

                var formattingContext2 = new FormattingContext
                {
                    LineEnding = lineEnding,
                    IndentSize = printerOptions.TabWidth,
                    UseTabs = printerOptions.UseTabs,
                    NewLineBeforeOpenBrace = printerOptions.NewLineBeforeOpenBrace,
                    NewLineBeforeElse = printerOptions.NewLineBeforeElse,
                    NewLineBeforeCatch = printerOptions.NewLineBeforeCatch,
                    NewLineBeforeFinally = printerOptions.NewLineBeforeFinally,
                    NewLineBeforeMembersInObjectInitializers = printerOptions.NewLineBeforeMembersInObjectInitializers,
                    NewLineBeforeMembersInAnonymousTypes = printerOptions.NewLineBeforeMembersInAnonymousTypes,
                    NewLineBetweenQueryExpressionClauses = printerOptions.NewLineBetweenQueryExpressionClauses,
                    UsePrettierStyleTrailingCommas = printerOptions.UsePrettierStyleTrailingCommas
                };
                document = Node.Print(
                    await syntaxTree.GetRootAsync(cancellationToken),
                    formattingContext2
                );
                formattedCode = DocPrinter.DocPrinter.Print(document, printerOptions, lineEnding);
                reorderedModifiers = reorderedModifiers || formattingContext2.ReorderedModifiers;
                reorderedUsingsWithDisabledText =
                    reorderedUsingsWithDisabledText
                    || formattingContext2.ReorderedUsingsWithDisabledText;
            }

            return new CodeFormatterResult
            {
                Code = formattedCode,
                DocTree = printerOptions.IncludeDocTree
                    ? DocSerializer.Serialize(document)
                    : string.Empty,
                AST = printerOptions.IncludeAST ? PrintAST(rootNode) : string.Empty,
                ReorderedModifiers = reorderedModifiers,
                ReorderedUsingsWithDisabledText = reorderedUsingsWithDisabledText,
            };
        }
        catch (InTooDeepException)
        {
            return new CodeFormatterResult
            {
                FailureMessage = "We can't handle this deep of recursion yet."
            };
        }
    }

    private static string PrintAST(CompilationUnitSyntax rootNode)
    {
        try
        {
            var stringBuilder = new StringBuilder();
            SyntaxNodeJsonWriter.WriteCompilationUnitSyntax(stringBuilder, rootNode);
            // SyntaxNodeJsonWriter doesn't write things indented, so this cleans it up for us
            return JsonSerializer.Serialize(
                JsonSerializer.Deserialize<object>(stringBuilder.ToString()),
                new JsonSerializerOptions { WriteIndented = false }
            );
        }
        // in some cases with new unsupported c# language features
        // SyntaxNodeJsonWriter will not produce valid json
        catch (JsonException ex)
        {
            return JsonSerializer.Serialize(
                new { exception = ex.ToString() },
                new JsonSerializerOptions { WriteIndented = false }
            );
        }
    }
}
