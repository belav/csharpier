public class ClassRules
{
    public void NeverLineBeforeFirstMember() { }
    public void AlwaysLineBetweenMethods() { }
    public void EvenWithLambdaBody() => "";
    private enum AlwaysLineBeforeEnum
    {
        One,
        Two
    }

    private enum NoDoubleLines
    {
        One,
        Two
    }
    private class AlwaysLineBeforeClass { }

    private class NoDoubleLines { }
    private interface IAlwaysLineBeforeInterface { }

    private interface INoDoubleLines { }
    public ClassRules() { }

    public ClassRules() { }
    public ~ClassName() { }

    public ~ClassName() { }
    public static implicit operator ClassRules(string s)
    {
        return new Test();
    }

    public static implicit operator ClassRules(int i)
    {
        return new Test();
    }
    public record SomeRecord1(string property);

    public record SomeRecord2(string property);
    public struct SomeStruct1 { }

    public struct SomeStruct2 { }
    static ClassRules operator +(ClassRules a, ClassRules b)
    {
        return a.Add(b);
    }

    static ClassRules operator -(ClassRules a, ClassRules b)
    {
        return a.Subtract(b);
    }

    private string FieldsCanBeGroupedBecauseLinesWillBeKept;
    private string ButLinesAreNotForcedHere;
    // comments force a line
    private string FieldWithComment;
    /* comments force a line */
    private string FieldWithComment;
    /// <summary> comments force a line </summary> ///
    private string FieldWithComment;
    [AttributesForceALine]
    private string FieldWithAttribute;

    private string PropertiesCanBeGrouped { get; set; }
    private string BecauseTheyDontForceLines { get; set; }
    // comments force a line
    private string PropertyWithComment;
    [AttributesForceALine]
    private string PropertyWithAttribute;
    
    delegate void DelegatesAreLikeFields();
    delegate void AndCanBeGrouped();
    // comments force a line
    delegate void DelegateWithComment();
    [AttributesForceALine]
    delegate void DelegateWithAttribute();
    
    public void AlwaysLineBetweenMethods() { }
    private string FieldAfterMethodGetsLine;

#if EDGE_CASE_SHOULD_KEEP_LINE_ABOVE_METHOD
    private string Field;
#else
    private string Field;
#endif

    public void SomeMethod() { }

#pragma warning disable 0618
    public void KeepLineAboveAndBelow() { }
#pragma warning restore 0618    

    public void SomeMethod() { }
}
public class LineBeforeClass { }
public interface InterfaceRulesAreLikeClassesButMethodsFollowTheFieldRulesAbove
{
    void NeverLineHere();
    
    void ExistingLineHereIsKept();
    void ButNoLineIsAdded();
    // comments do force a line
    void MethodWithComment();
}

abstract class AbstractClass
{
    abstract void NoLineHere() { }
    
    abstract void KeepTheLineHere();
    abstract void DoNotForceTheLineHere();
    void ButForceLineForRealMethod() { }
}

public class ClassName
{
    private string someField1;

#if KEEP_LINE_ABOVE
    private string someField2;
#endif

    private string someField2;
}

public class ClassName
{
#region RegionWithSpaceBeforeAndAfterMethod

    void SomeMethod() { }

#endregion

    void SomeMethod() { }
}
