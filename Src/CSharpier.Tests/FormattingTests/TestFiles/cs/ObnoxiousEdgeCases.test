// these are here so we can see how they change over time, see https://github.com/belav/csharpier/issues/272
// try to clean these up if you are modifying formatting that affects them.
class ClassName
{
    public readonly StackObjectPool<
        Dictionary<object, KeyedItemInfo>
    > KeyedItemInfoDictionaryPool_____;

    internal StackObjectPool<
        Dictionary<object, KeyedItemInfo>
    > KeyedItemInfoDictionaryPool { get; } =
        new StackObjectPool<Dictionary<object, KeyedItemInfo>>(
            maxPreservedItems: 10,
            () => new Dictionary<object, KeyedItemInfo>()
        );

    RenderFragment<AuthenticationState> customNotAuthorized = state =>
        builder => builder.AddContent(0, $"Go away, {state.User.Identity.Name}");

    public List<(
        ClaimsPrincipal user,
        object resource,
        IEnumerable<IAuthorizationRequirement> requirements
    )> AuthorizeCalls { get; } =
        new List<(
            ClaimsPrincipal user,
            object resource,
            IEnumerable<IAuthorizationRequirement> requirements
        )>();

    private static readonly Action<ILogger, string, string, Exception> _displayingNotFound =
        LoggerMessage.Define<string, string>(
            LogLevel.Debug,
            new EventId(1, "DisplayingNotFound"),
            $"Displaying {nameof(NotFound)} because path '{{Path}}' with base URI '{{BaseUri}}' does not match any component route"
        );

    private static readonly Action<
        ILogger,
        Type,
        string,
        string,
        Exception
    > _navigatingToComponent = LoggerMessage.Define<Type, string, string>(
        LogLevel.Debug,
        new EventId(2, "NavigatingToComponent"),
        "Navigating to component {ComponentType} in response to path '{Path}' with base URI '{BaseUri}'"
    );

    public void MethodName()
    {
        builder_________________.OpenComponent<
            SecondCascadingParameterConsumerComponent<string, int>
        >(0);
    }

    public static IRemoteAuthenticationBuilder<
        RemoteAuthenticationState,
        RemoteUserAccount
    > AddAccountClaimsPrincipalFactory<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)]
            TAccountClaimsPrincipalFactory
    >(this IRemoteAuthenticationBuilder<RemoteAuthenticationState, RemoteUserAccount> builder)
        where TAccountClaimsPrincipalFactory : AccountClaimsPrincipalFactory<RemoteUserAccount> =>
        builder.AddAccountClaimsPrincipalFactory<
            RemoteAuthenticationState,
            RemoteUserAccount,
            TAccountClaimsPrincipalFactory
        >();

    private static readonly Action<IApplicationBuilder> ActionNotImplemented =
        new Action<IApplicationBuilder>(_ =>
        {
            throw new NotImplementedException();
        });

    public void MapFrom<TResult>(Func<TSource, TDestination, TMember, TResult> mappingFunction)
    {
        if (true)
        {
            PropertyMapActions.Add(pm =>
            {
                Expression<Func<TSource, TDestination, TMember, ResolutionContext, TResult>> expr =
                    (src, dest, destMember, ctxt) => mappingFunction(src, dest, destMember);

                pm.CustomMapFunction = expr;
            });
        }
    }

    public void Condition(
        Func<ConditionParameters<TSource, TDestination, TMember>, bool> condition
    ) =>
        PathMapActions.Add(pm =>
        {
            Expression<
                Func<TSource, TDestination, TMember, TMember, ResolutionContext, bool>
            > expr = (src, dest, srcMember, destMember, ctxt) =>
                condition(
                    new ConditionParameters<TSource, TDestination, TMember>(
                        src,
                        dest,
                        srcMember,
                        destMember,
                        ctxt
                    )
                );
            pm.Condition = expr;
        });

    public override Type SourceType
    {
        get =>
            _sourceType ??=
                CustomMapExpression?.ReturnType
                ?? CustomMapFunction?.ReturnType
                ?? (
                    _sourceMembers.Length > 0
                        ? _sourceMembers[_sourceMembers.Length - 1].GetMemberType()
                        : Parameter.ParameterType
                );
        protected set => _sourceType = value;
    }

    public static Expression IfNullElse(
        this Expression expression,
        Expression then,
        Expression @else
    ) =>
        expression.Type.IsValueType
            ? (
                expression.Type.IsNullableType()
                    ? Condition(Property(expression, "HasValue"), ToType(@else, then.Type), then)
                    : @else
            )
            : Condition(ReferenceEqual(expression, Null), then, ToType(@else, then.Type));

    private bool VisitChildForCompare(Pair<XmlNode> tuple, ref int result)
    {
        int r;
        return 0
            != (
                result =
                    (null == tuple.Item1) ? -1
                    : (null == tuple.Item2) ? +1
                    : 0 != (r = comparer.Compare(tuple.Item1.LocalName, tuple.Item2.LocalName)) ? r
                    : 0
                    != (r = comparer.Compare(tuple.Item1.NamespaceURI, tuple.Item2.NamespaceURI))
                    ? r
                    : 0
            );
    }
}
